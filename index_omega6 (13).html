
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Omniscientrix Universe Map vΩ.6 — Enhanced Engine</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000;color:#9ee7ff;font-family:Arial;}
#uiPanel{
 position:fixed;top:20px;left:20px;
 background:rgba(0,20,40,0.55);border:1px solid #00d0ff55;
 padding:15px;border-radius:14px;backdrop-filter:blur(8px);
 color:#b9f2ff;max-width:260px;transition:0.3s;
}
#uiPanel h1{font-size:20px;margin:0 0 10px;color:#4ee6ff;text-shadow:0 0 6px #0099cc;}
canvas{display:block;}
#footer{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);
 font-size:12px;color:#00baff;}
#footer a{color:#66e0ff;text-decoration:none;}
</style>
</head>
<body>

<div id="uiPanel">
<h1>Ω Control Panel</h1>
<label>Mode:</label>
<select id="modeSel">
<option value="life">Ω-Life Resonance</option>
<option value="curv">Ω-Curvature</option>
<option value="aware">Awareness Field</option>
<option value="flux">Info Flux</option>
<option value="ghz">GHZ Adaptive</option>
<option value="star">Star Blackbody</option>
</select>
<br/><br/>
<label>Ω-Intensity</label>
<input type="range" id="omegaInt" min="0" max="1" step="0.01" value="0.7"/>
<br/><br/>
<label>Adaptive Engine</label>
<input type="checkbox" id="adaptive" checked/> Enabled
</div>

<canvas id="universe"></canvas>

<div id="footer">
© 2025 Cornelius Aurelius · 
<a href="https://corneliusaurelius.com/">Site</a> ·
<a href="https://medium.com/@138licensing">Medium</a> ·
<a href="mailto:138licensing@gmail.com">Email</a> ·
<a href="https://zenodo.org/records/17362534">Zenodo</a> ·
<a href="https://www.instagram.com/cornelius_aurelius_/">Instagram</a> ·
<a href="https://www.linkedin.com/in/cornelius-aurelius-404805325/recent-activity/all/">LinkedIn</a>
</div>

<script>
const canvas=document.getElementById("universe");
const ctx=canvas.getContext("2d");
let W,H;
function resize(){W=canvas.width=innerWidth;H=canvas.height=innerHeight;}
resize();addEventListener("resize",resize);

let cam={x:0,y:0,z:1600,drag:false,lx:0,ly:0};

canvas.addEventListener("mousedown",e=>{cam.drag=true;cam.lx=e.clientX;cam.ly=e.clientY;});
addEventListener("mouseup",()=>cam.drag=false);
canvas.addEventListener("mousemove",e=>{
 if(cam.drag){
  cam.x -= (e.clientX-cam.lx)*1.1;
  cam.y -= (e.clientY-cam.ly)*1.1;
  cam.lx=e.clientX;cam.ly=e.clientY;
 }
});
canvas.addEventListener("wheel",e=>{
 cam.z += e.deltaY*0.5;
 cam.z=Math.max(300,Math.min(6000,cam.z));
});

// Ω-touch + inertia
let tId=null;
canvas.addEventListener("touchstart",e=>{
 if(e.touches.length===1){
  tId=e.touches[0].identifier;
  cam.drag=true;
  cam.lx=e.touches[0].clientX;
  cam.ly=e.touches[0].clientY;
 }
});
canvas.addEventListener("touchmove",e=>{
 for(const t of e.touches){
  if(t.identifier===tId && cam.drag){
   cam.x -= (t.clientX-cam.lx)*1.1;
   cam.y -= (t.clientY-cam.ly)*1.1;
   cam.lx=t.clientX;cam.ly=t.clientY;
  }
 }
});
canvas.addEventListener("touchend",()=>{cam.drag=false;tId=null;});

// ====== Enhanced Ω Starfield ======
let stars=[];
for(let i=0;i<30000;i++){
 stars.push({
  x:(Math.random()-0.5)*40000,
  y:(Math.random()-0.5)*40000,
  z:200+Math.random()*9000,
  temp:2500+Math.random()*20000,
  aware:Math.random(),
  flux:Math.random()
 });
}

function colorTemp(T){
 if(T<3500)return"rgba(255,100,60,0.9)";
 if(T<5000)return"rgba(255,180,120,0.9)";
 if(T<6500)return"rgba(255,255,200,0.9)";
 if(T<9000)return"rgba(180,200,255,0.9)";
 return"rgba(150,180,255,0.9)";
}

const modeSel=document.getElementById("modeSel");
const omegaInt=document.getElementById("omegaInt");
const adaptive=document.getElementById("adaptive");

// Ω-field functions
function omegaCurv(s,om){return `rgba(0,${120+om*120},255,${0.4*s.z/cam.z})`;}
function omegaAware(s,om){return `rgba(${om*255},0,${200+om*55},${s.aware*0.9})`;}
function omegaFlux(s,om){return `rgba(0,255,150,${s.flux*om})`;}

// GHZ weighting
function ghzWeight(x,y){
 let r=Math.sqrt(x*x+y*y);
 return Math.exp(-Math.abs(r-12000)/5000);
}

function render(){
 ctx.fillStyle="#000";ctx.fillRect(0,0,W,H);
 let om=Number(omegaInt.value);
 let mode=modeSel.value;
 let adapt=adaptive.checked;

 for(const s of stars){
  let d=s.z/cam.z;
  let X=W/2+(s.x-cam.x)*1.05/d;
  let Y=H/2+(s.y-cam.y)*1.05/d;

  let C;
  if(mode==="curv")C=omegaCurv(s,om);
  else if(mode==="aware")C=omegaAware(s,om);
  else if(mode==="flux")C=omegaFlux(s,om);
  else if(mode==="ghz")C=`rgba(0,${Math.floor(ghzWeight(s.x,s.y)*255)},255,0.9)`;
  else if(mode==="star")C=colorTemp(s.temp);
  else if(mode==="life")C=`rgba(${Math.floor(s.aware*120)},${Math.floor(s.flux*255)},255,1)`;
  else C=colorTemp(s.temp);

  ctx.fillStyle=C;
  ctx.fillRect(X,Y,1.2,1.2);
 }

 requestAnimationFrame(render);
}
render();
</script>

</body>
</html>

<!-- Ω MODULE EXTENSION PLACEHOLDER -->
<script>
// Additional Ω-physics kernels (curvature, awareness-energy, entropy-area)
console.log("Ω-Physics Module Loaded");
</script>

<!-- Ω-Speed Rendering Kernel -->
<script>
// Hyper-Quantum Ω-Speed Kernel — Adaptive Performance + Smooth Movement

(function(){

    let lastTime = performance.now();
    let fpsSmoothing = 0.90;
    let targetFPS = 60;
    let frameDelta = 0;

    // Adaptive render timing
    window.OmegaSpeed = {
        dt: 0.016,
        speedFactor: 1,
        update: function(){
            const now = performance.now();
            const elapsed = (now - lastTime) / 1000;
            lastTime = now;

            // Smooth delta time
            this.dt = this.dt * fpsSmoothing + elapsed * (1 - fpsSmoothing);

            // Adaptive speed factor based on device performance
            if (this.dt > 0.03) this.speedFactor = 0.7;
            else if (this.dt > 0.02) this.speedFactor = 0.85;
            else this.speedFactor = 1.0;
        }
    };

    // Touch/mouse movement stabilizer
    window.OmegaMotion = {
        vx: 0, vy: 0,
        damping: 0.90,
        applyInertia: function(cam){
            cam.x -= this.vx * OmegaSpeed.speedFactor;
            cam.y -= this.vy * OmegaSpeed.speedFactor;
            this.vx *= this.damping;
            this.vy *= this.damping;
        }
    };

})();
</script>

<!-- Ω-Curvature Engine -->
<script>
// Informational Curvature Module — R_info = R + 16πGβ KL
(function(){
    window.OmegaCurvature = {
        beta: 1.0,
        compute: function(s){
            // basic curvature weight placeholder
            const dx = s.x, dy = s.y;
            const r = Math.sqrt(dx*dx + dy*dy);
            const KL = Math.exp(-r/15000); 
            return KL * this.beta;
        }
    };
    console.log("Ω-Curvature Engine Loaded");
})();
</script>

<!-- Ω Awareness‑Energy Tensor Engine -->
<script>
// Awareness‑Energy Tensor Ξ_{μν} = ∂μA ∂νA − g_{μν} L_A
(function(){
    window.OmegaAwareness = {
        // awareness field strength
        A: function(s){
            // synthetic awareness potential (can be upgraded later)
            return (Math.sin(s.x/8000) + Math.cos(s.y/9000)) * 0.5 + 0.5;
        },
        // tensor contribution
        tensor: function(s){
            const A = this.A(s);
            const dAx = (Math.cos(s.x/8000) / 8000);
            const dAy = (-Math.sin(s.y/9000) / 9000);

            // simplified 2D tensor slice
            return {
                xx: dAx*dAx - A*0.1,
                yy: dAy*dAy - A*0.1,
                xy: dAx*dAy
            };
        },
        // awareness‑energy color mapping
        color: function(s, intensity){
            const A = this.A(s);
            const t = Math.min(1, Math.max(0, A * intensity));
            const r = Math.floor(80 + t*175);
            const g = Math.floor(20 + t*60);
            const b = Math.floor(140 + t*115);
            return `rgba(${r},${g},${b},${0.85})`;
        }
    };
    console.log("Ω Awareness‑Energy Tensor Engine Loaded");
})();
</script>

<!-- Ω Entropy–Area Horizon Engine -->
<script>
// Horizon Engine: detects curvature+awareness peaks for horizon rings
(function(){
    window.OmegaHorizon = {
        compute: function(s){
            // synthetic horizon intensity using curvature + awareness
            const r = Math.sqrt(s.x*s.x + s.y*s.y);
            const curv = Math.exp(-r/15000);
            const aware = (Math.sin(s.x/7000) + Math.cos(s.y/8000))*0.5+0.5;
            return (curv*0.6 + aware*0.4);
        },
        color: function(h){
            const t = Math.min(1, Math.max(0, h));
            const r = Math.floor(200 + t*55);
            const g = Math.floor(80  + t*40);
            const b = Math.floor(20  + t*200);
            return `rgba(${r},${g},${b},${0.75})`;
        }
    };
    console.log("Ω Horizon Engine Loaded");
})();
</script>

<!-- Ω Life-Resonance Engine (vΩ‑147) -->
<script>
// Life Resonance ω_life ∝ √(A / D_KL)
(function(){
    window.OmegaLife = {
        // atmospheric KL divergence approximation
        KL: function(s){
            // synthetic KL term — stable + fast
            const r = Math.sqrt(s.x*s.x + s.y*s.y);
            return Math.max(0.001, Math.exp(-r/12000));
        },
        // awareness A(x,y) pulled from Awareness Engine
        A: function(s){
            return window.OmegaAwareness.A(s);
        },
        // resonance frequency
        resonance: function(s){
            const A = this.A(s);
            const KL = this.KL(s);
            return Math.sqrt(A / KL);
        },
        // color mapping
        color: function(s, intensity){
            const L = this.resonance(s) * intensity;
            const t = Math.min(1, Math.max(0, L / 3.0));
            const r = Math.floor(40 + t*200);
            const g = Math.floor(80 + t*120);
            const b = Math.floor(255 - t*180);
            return `rgba(${r},${g},${b},0.9)`;
        }
    };
    console.log("Ω Life-Resonance Engine Loaded");
})();
</script>

<!-- Ω Collapse–Diffusion Engine -->
<script>
// Informational Collapse–Diffusion Engine
// Implements KL-gradient diffusion + collapse stabilization
(function(){
    window.OmegaCollapse = {
        diffusionRate: 0.002,
        collapseThreshold: 0.015,

        KL: function(s){
            const r = Math.sqrt(s.x*s.x + s.y*s.y);
            return Math.max(0.0001, Math.exp(-r/10000));
        },

        // diffusion: smooths informational gradients
        diffuse: function(val){
            return val * (1 - this.diffusionRate);
        },

        // collapse stabilization
        collapse: function(val){
            if(val < this.collapseThreshold){
                return val * 0.5; // collapse toward equilibrium
            }
            return val;
        },

        // combined operator
        evolve: function(s){
            let v = this.KL(s);
            v = this.diffuse(v);
            v = this.collapse(v);
            return v;
        },

        // color mapping for collapse zones
        color: function(v){
            const t = Math.min(1, Math.max(0, v * 50));
            const r = Math.floor(255 * t);
            const g = Math.floor(120 * t);
            const b = Math.floor(255 - 200 * t);
            return `rgba(${r},${g},${b},0.85)`;
        }
    };
    console.log("Ω Collapse–Diffusion Engine Loaded");
})();
</script>

<!-- Ω Multi-Field Blending Engine -->
<script>
// Unifies all Ω-fields into a single adaptive render weight
(function(){
    window.OmegaBlend = {
        blend: function(curv, aware, horizon, life, collapse, intensity){
            // Weighted blend of all fields
            let v = (
                curv*0.22 +
                aware*0.18 +
                horizon*0.20 +
                life*0.28 +
                collapse*0.12
            ) * intensity;
            return Math.min(1, Math.max(0, v));
        },
        color: function(b){
            // rich blended Ω-color
            const r = Math.floor(80 + b*170);
            const g = Math.floor(40 + b*150);
            const b2 = Math.floor(220 - b*160);
            return `rgba(${r},${g},${b2},0.85)`;
        }
    };
    console.log("Ω Multi-Field Blending Engine Loaded");
})();
</script>

<!-- Ω Quantum GHZ Engine -->
<script>
// Quantum GHZ Engine — curvature + awareness + collapse + life resonance
(function(){
    window.OmegaGHZ = {
        weight: function(s){
            const r = Math.sqrt(s.x*s.x + s.y*s.y);
            const curv = Math.exp(-Math.abs(r-12000)/5000);
            const aware = (Math.sin(s.x/6000)+Math.cos(s.y/6000))*0.5+0.5;
            const collapse = window.OmegaCollapse.evolve(s);
            return (curv*0.45 + aware*0.35 + collapse*0.20);
        },
        color: function(w){
            const t = Math.min(1, Math.max(0, w));
            const r = Math.floor(40 + t*200);
            const g = Math.floor(200 + t*30);
            const b = Math.floor(255 - t*180);
            return `rgba(${r},${g},${b},0.9)`;
        }
    };
    console.log("Ω Quantum GHZ Engine Loaded");
})();
</script>
